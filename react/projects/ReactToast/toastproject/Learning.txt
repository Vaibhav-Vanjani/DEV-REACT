âœ… 1. React State Immutability
âŒ What you did:
arr.push({ id: cnt, message: textMessage });
setArr(arr); // set the same (mutated) array

âœ… What you should do:
setArr(prev => [...prev, newToast]);

ðŸ’¡ Concept:

State in React must be treated as immutable.
Mutating an array (.push(), .splice(), .shift()) and calling setState with it doesn't change the reference, so React doesnâ€™t re-render.

âœ… 2. Functional State Updates to Avoid Stale Closures
âŒ What you did:
setTimeout(() => {
  const newArr = arr.slice(1);
  setArr(newArr);
}, 2000);

âœ… What you should do:
setTimeout(() => {
  setArr(prev => prev.filter(toast => toast.id !== id));
}, 2000);

ðŸ’¡ Concept:

When using setTimeout, you're creating a closure â€” it captures the value of arr at the time the function is created.
If arr updates later (e.g., more toasts added), your timeout still references the old arr.

ðŸ”‘ Fix: Use functional state updates: setArr(prev => ...)
This guarantees you're working with the latest state inside async callbacks.

âœ… 3. Multiple Independent Timers
âŒ What you did:
setTimeout(() => {
  const newArr = arr.slice(1); 
  setArr(newArr);
}, 2000);

âœ… What you should do:
setTimeout(() => {
  setArr(prev => prev.filter(toast => toast.id !== id));
}, 2000);

ðŸ’¡ Concept:

If you only use arr.slice(1), you always remove the first toast regardless of which one was added.
This doesn't scale if multiple toasts are added quickly â€” the wrong one might disappear, or you'll have race conditions.

ðŸ”‘ Fix: Assign each toast a unique ID, then remove that specific toast after its own timeout.

âœ… 4. Separation of Concerns (Adding vs Removing Toasters)
âŒ What you did:

Add toast

Set timeout to shift entire array

âœ… What you should do:

Add toast with ID

Set timeout to remove that specific toast

ðŸ’¡ Concept:

Each toast should manage its own lifecycle (when to be added and when to be removed), not rely on array position or order.

This decouples your UI logic and prevents bugs when many toasts are shown at once.

âœ… 5. React Strict Mode (double renders in development)
âŒ What you might have noticed:

Your setTimeout fired twice unexpectedly during dev

ðŸ’¡ Concept:

React Strict Mode intentionally double-invokes functions to help catch side-effects (like timers or API calls) that should be wrapped in useEffect or controlled more carefully.

You handled this fine, but it's good to know why weird things can happen when coding in development.

ðŸ” Summary: Concepts You Were Missing
Concept	What You Missed	What You Learned
âœ… Immutable state	Used arr.push() and arr.shift()	Use [...arr, item] and arr.filter()
âœ… Functional state updates	Used old state in setTimeout	Use setState(prev => ...) to get fresh state
âœ… Toast identity	Removed first item blindly (slice(1))	Use unique IDs to target specific toasts
âœ… Async closures	Used stale arr inside timeout	Closures freeze variable values unless handled functionally
âœ… Decoupled logic	One timer affecting the whole array	Each toast manages its own timeout via id
âœ… React rendering behavior	Didn't expect inconsistent UI	React doesn't re-render on mutated objects
ðŸ§  If You Want to Keep Leveling Up

Here are some topics related to what youâ€™ve just learned:

ðŸ”„ useEffect and cleanup for timers

ðŸ’¥ useReducer for complex toast logic (like pause/resume)

ðŸ§± Building a ToastManager component

ðŸ“¦ Using libraries like react-toastify and comparing with your approach


----
learned about map - key (react checks old state by key)

data-* for any attribute to passed 
acccessed in dataset in event objects

react wants each state value to be changed by reference

access previous state by function arrow 

